# KiCad Bill-of-Materials Generator
Let's face it... Generating BOMs from KiCad **SUCKS**. This program is looking to change that.

### It's the ★·.·´¯\`·.·★ BOMdigity ★·.·´¯\`·.·★

What this program allows you to do is generate much more friendly output when you're ready
to make your Bill-of-Materials. With the option of completely being able to customize the
internal workings, you can modify, upgrade, and extend this program to your hearts desire.

# Pipeline
This program implements a pipeline. This pipeline is responsible for the entire process implemented by this program.

Here is a nice diagram that demonstrations the pipeline (descriptions of each below):
![Parser -> Middleware -> Formatter](diagram.png)

## Parser
The parser will read in netlist file generated by KiCad, and build a list of components that are used. And then pass them through the pipeline.

The parser will pull all the field data from components, so if you want any special information (part numbers, serial numbers, datasheets, etc...) then you will need to add that information for each component (or better yet, add it to the component in the component library).

## Middleware
This program implements what is known as middleware. Middleware runs between
parsing and retrieving components and the formatter. It can be responsible for a lot
of different tasks. For example:
- Sorting the list of components
- Referencing a database and injecting other data (serial numbers, distributor part numbers, etc)
- Verifying components against some other source

Read the [Middleware Read Me](Middleware/README.md) for more information.

## Formatters
Formatters let you output your BOM in different formats.

Currently, this program can generate a BOM in the following formats:
- Excel
- Comma Separated Value (CSV)
- JSON

Read the [Formatters Read Me](Formatter/README.md) for more information.

## Afterware
Afterware is another pipeline (like middleware) except it will operate on a copy of the file generated by the formatter.

An example of afterware would be to make a copy of the BOM and put it in an archive.

Read the [Afterware Read Me](Afterware/README.md) for more information.




# Usage
This program can be ran directly from inside KiCad!

## Setup
1. Open Eeschema
2. Click on the `Tools > Generate Bill of Materials`
3. Click `Add Plugin` on the right hand side
4. Browse to this folder and select the `kicad_bom_generator.py` file
5. Click `Open`
6. Type in a meaningful name

Now, whenever you are ready to generate your BOM, just select the name that you typed in where it is listed under "`Plugins`" and then click "`Generate`"


## Changing Output Format
If you want to *temporarily* change the output type, in the "`Command Line`" field when you have the plugin selected add `"formatter-name"` to the end (separated by a space from the thing before it [including quotes]). And then click "`Generate`"

### Example
Here are some examples of what you can put in the "`Command line`" field in KiCad:

`python "[path]\kicad_bom_generator.py" "%I" "%O" "excel"` would output in Excel format

`python "[path]\kicad_bom_generator.py" "%I" "%O" "csv"` would output in CSV

`python "[path]\kciad_bom_generator.py" "%I" "%O"` would output in the formatter specified in `config.json` (see below) or error (if nothing is set in the config)


## Command Line Help
Since `kicad_bom_generator.py` is runnable directly from the command line, you can run the following command to see available arguments:

`kicad_bom_generator.py -h`


# Configuration
This program is configurable using the `config.json` file.

This file controls default values, metadata information, middleware, and formatter output.

This table shows a valid attribute, type, and value, of the `config.json` file:

Name | Type | Description
-----|------|-------------
`formatter` | string | The formatter to use if no formatter is speficied in the argumnets
`middleware` | []string | This is the list of middleware to run the component list through, *order matters*. This is referred to as the *middleware pipeline*.
`afterware` | []string | This is the list of afterware to run, *order matters*. This is referred to as the *afteware pipeline*.
`metadataAliases` | object | This object will allow for common variants of metadata to point to another metadata value. This should be a dictionary, e.g.: `{ "alias": "real_name" }`
`columns` | []string | the metadata names for the columns to show, *order matters*.
`outputLineSeparator` | string | If you are outputing in CSV format then this is what will be used to separate rows. This can be anything you want, a good default value is: "`\n`"
`emptyValue` | string | Value to put in the output column if a component doesn't have anything for that column

Here is a complete example of `config.json`:
```json
{
  "formatter": "excel",
  "middleware": ["sort"],
  "afterware": [],

  "debug": false,
  "verbose": false,

  "metadataAliases": {
    "supplier": "supplier_name",
    "supplier_part_number": "supplier_part",
    "manufacturer": "manufacturer_name",
    "manufacturer_part_number": "manufacturer_part"
  },

  "columns": ["name", "supplier_name", "supplier_part", "quantity", "reference"],

  "outputLineSeparator": "\n"
}
```

# Testing
To perform all the tests run:

```py
pip install lxml
pytest
```

# Switch to Python
This project was originally implemented in Go. However, once complete it was switched to Python for a couple of reasons.

- Cross-Platform compatability without needing to install a Go compiler and building the project
- Ability to edit (add new Middleware and new Formatters) without recompilling the source code